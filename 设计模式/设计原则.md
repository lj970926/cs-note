# 1. 依赖倒置原则(DIP)
* 高层模块（稳定）不应该依赖于低层模块（变化），二者都应依赖于抽象（稳定）
	* 高层模块不直接使用低层模块，而是使用其抽象类
* 抽象不应依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）
	* 抽象类不能使用子类
	* 有助于隔离变化
	![image.png](https://raw.githubusercontent.com/lj970926/image-hosting/master/images/20241227223214.png)

# 2. 开放封闭原则(OCP)
* 对拓展开放，对修改封闭
* 类模块应该可扩展，而不可修改
	* 当需求变化时，应该首先考虑增加一些东西应对需求的变化，而不是到处改动现有代码。
# 3. 单一职责原则(SRP)
* 一个类应该仅有一个引起它变化的原因
* 变化的方向隐含着类的责任
	* 当一个类存在非常多的方法时很可能意味着该类有多个 责任，违反该原则
# 4. Liskov替换原则 (LSP)
* 子类必须能够替换它们的基类
	* 本质上是继承的is-a关系
* 继承表达类型抽象
# 5. 接口隔离原则 (ISP)
 * 不应使客户程序依赖他们不用的方法
 * 接口应该小而完备
	 * 尽可能把方法声明为protected和private，不要public
# 6. 优先使用对象组合，而不是继承
* 继承是白箱复用，组合是黑箱复用
* 继承在某种程度上破坏了封装性，子类父类耦合度比较高(父类实际上暴露了一部分实现），而组合只依赖对象的公共接口，耦合度低
# 7. 封装变化点
* 使用封装创建对象之间的抽象层，使设计者可以在一侧进行修改而不会影响另一侧
# 8. 针对接口编程，而不是针对实现编程
* 不将变量声明为某个具体类，而是声明为累的接口（抽象类）
* 减少依赖关系，实现高内聚-低耦合

上面这些原则在实际场景中通常是相辅相成的，违背了其中一个通常也会违背其他的原则
